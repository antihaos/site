<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Методы сжатия видеоданных - Конспект лекции</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --accent-primary: #00d4ff;
            --accent-secondary: #ff2e63;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border-color: #2d3748;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(26, 26, 46, 0.8);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
        }

        .lecture-title {
            font-size: 2.5em;
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 10px;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .lecture-subtitle {
            font-size: 1.2em;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 30px;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .section {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid var(--border-color);
            position: relative;
            scroll-margin-top: 20px;
        }

        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        .section-title {
            font-size: 1.8em;
            color: var(--accent-primary);
            margin-bottom: 20px;
            border-bottom: 3px solid var(--accent-primary);
            padding-bottom: 10px;
            font-weight: 600;
        }

        .subsection {
            margin-bottom: 25px;
        }

        .subsection-title {
            font-size: 1.3em;
            color: var(--text-primary);
            margin-bottom: 15px;
            font-weight: 600;
        }

        .text-content {
            margin-bottom: 20px;
            text-align: justify;
            color: var(--text-secondary);
        }

        .diagram {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid var(--border-color);
            overflow-x: auto;
        }

        .code-block {
            background: #1e293b;
            color: var(--text-primary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .code-block::before {
            content: 'Python';
            position: absolute;
            top: 0;
            right: 0;
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 4px 10px;
            font-size: 0.8em;
            border-radius: 0 10px 0 10px;
            font-weight: bold;
        }

        .formula {
            background: #1e293b;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid var(--accent-secondary);
            font-family: 'Cambria Math', serif;
        }

        .formula-title {
            font-size: 1.1em;
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .formula-explanation {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-secondary);
            text-align: left;
        }

        .katex-formula {
            font-size: 1.1em;
            overflow-x: auto;
            color: var(--text-primary);
            text-align: center;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-secondary);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .comparison-table th {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .comparison-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.05);
        }

        .comparison-table tr:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        .highlight {
            background: linear-gradient(120deg, rgba(0, 212, 255, 0.2) 0%, rgba(255, 46, 99, 0.2) 100%);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
            color: var(--accent-primary);
        }

        .navigation {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(26, 26, 46, 0.9);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            z-index: 100;
            max-height: 80vh;
            overflow-y: auto;
        }

        .nav-item {
            display: block;
            padding: 10px 15px;
            margin: 5px 0;
            background: var(--accent-primary);
            color: var(--bg-primary);
            text-decoration: none;
            border-radius: 5px;
            text-align: center;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-item:hover {
            background: var(--accent-secondary);
            transform: translateX(-5px);
        }

        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
            color: var(--text-secondary);
        }

        li {
            margin-bottom: 8px;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transform-origin: left;
            transform: scaleX(0);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .complexity-chart {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .complexity-item {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--accent-primary);
        }

        .complexity-title {
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 8px;
        }

        .mermaid {
            background: white;
            border-radius: 5px;
            padding: 10px;
            overflow-x: auto;
        }

        .codec-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .codec-card {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid var(--accent-primary);
            transition: transform 0.3s ease;
        }

        .codec-card:hover {
            transform: translateY(-5px);
        }

        .codec-name {
            font-size: 1.2em;
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .codec-type {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .lossless {
            background: rgba(0, 212, 255, 0.2);
            color: var(--accent-primary);
        }

        .lossy {
            background: rgba(255, 46, 99, 0.2);
            color: var(--accent-secondary);
        }

        .mobile-menu-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 101;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .mobile-menu-toggle:hover {
            background: var(--accent-secondary);
            transform: scale(1.1);
        }

        .quiz-section {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid var(--accent-secondary);
        }

        .quiz-question {
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-primary);
        }

        .quiz-options {
            margin-bottom: 15px;
        }

        .quiz-option {
            display: block;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .quiz-option:hover {
            background: rgba(0, 212, 255, 0.1);
        }

        .quiz-option.correct {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid rgba(0, 255, 0, 0.5);
        }

        .quiz-option.incorrect {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
        }

        .quiz-feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            display: none;
        }

        .quiz-feedback.correct {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid rgba(0, 255, 0, 0.5);
            display: block;
        }

        .quiz-feedback.incorrect {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.5);
            display: block;
        }

        .key-points {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(255, 46, 99, 0.1) 100%);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid var(--accent-primary);
        }

        .key-points-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--accent-primary);
        }

        .techniques-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .technique-card {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid var(--accent-secondary);
        }

        .technique-title {
            font-weight: 600;
            color: var(--accent-secondary);
            margin-bottom: 10px;
        }

        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .library-card {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid var(--accent-primary);
        }

        .library-name {
            font-size: 1.2em;
            color: var(--accent-primary);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .language-tabs {
            display: flex;
            margin-bottom: -1px;
            flex-wrap: wrap;
        }

        .language-tab {
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            margin-right: 5px;
            transition: all 0.3s ease;
        }

        .language-tab.active {
            background: #1e293b;
            color: var(--accent-primary);
            border-bottom: 1px solid #1e293b;
        }

        .code-content {
            display: none;
        }

        .code-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .navigation {
                display: none;
                width: 80%;
                right: 10%;
                top: 50%;
                transform: translateY(-50%);
            }

            .navigation.active {
                display: block;
            }

            .mobile-menu-toggle {
                display: block;
            }

            .lecture-title {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .section-title {
                font-size: 1.5em;
            }

            .header {
                padding: 25px;
            }

            .codec-grid {
                grid-template-columns: 1fr;
            }

            .complexity-chart {
                grid-template-columns: 1fr;
            }

            .techniques-grid {
                grid-template-columns: 1fr;
            }

            .library-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .lecture-title {
                font-size: 1.7em;
            }

            .section {
                padding: 15px;
            }

            .header {
                padding: 20px;
            }

            .container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progressBar"></div>

    <button class="mobile-menu-toggle" id="mobileMenuToggle">☰</button>

    <div class="navigation" id="navigation">
        <a href="#section1" class="nav-item">Введение</a>
        <a href="#section2" class="nav-item">Классификация</a>
        <a href="#section3" class="nav-item">Внутрикадровое сжатие</a>
        <a href="#section4" class="nav-item">Межкадровое сжатие</a>
        <a href="#section5" class="nav-item">Психовизуальные модели</a>
        <a href="#section6" class="nav-item">Стандарты сжатия</a>
        <a href="#section7" class="nav-item">Современные кодеки</a>
        <a href="#section8" class="nav-item">Форматы контейнеров</a>
        <a href="#section9" class="nav-item">Практика</a>
        <a href="#section10" class="nav-item">Программные реализации</a>
        <a href="#quiz" class="nav-item">Тест</a>
    </div>

    <div class="container">
        <div class="header">
            <h1 class="lecture-title">Методы сжатия видеоданных</h1>
            <p class="lecture-subtitle">Подробный конспект лекции для направления "Программная инженерия"</p>
        </div>

        <div class="content">
            <!-- Раздел 1: Введение -->
            <div class="section" id="section1">
                <h2 class="section-title">1. Введение: Проблема объема видеоданных</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Проблема больших объемов несжатого видео</h3>
                    <div class="text-content">
                        <p>Цифровое видео представляет собой последовательность изображений (кадров), которые воспроизводятся с определенной частотой. Без сжатия эти данные занимают огромный объем, что делает их хранение и передачу практически невозможной для большинства применений.</p>
                    </div>

                    <div class="diagram">
                        <div class="mermaid">
                            graph LR
                                A[Несжатое видео] --> B["4K видео: ~6 ГБ/минуту"]
                                B --> C[Слишком большой<br>для передачи/хранения]
                                C --> D[Решение:<br>сжатие данных]

                                subgraph Расчет_размера[Пример расчета 4K видео]
                                    E["3840×2160 пикселей × 24 бита × 30 кадров/с × 60 сек"]
                                    E --> F["~35 ГБ/минуту без сжатия"]
                                end
                        </div>
                    </div>

                    <div class="text-content">
                        <p><strong>Детальный расчет:</strong></p>
                        <ul>
                            <li><span class="highlight">Разрешение 4K (3840×2160)</span>: 8,294,400 пикселей на кадр</li>
                            <li><span class="highlight">Глубина цвета 24 бита</span>: 3 байта на пиксель (RGB)</li>
                            <li><span class="highlight">Частота кадров 30 fps</span>: 30 кадров в секунду</li>
                        </ul>

                        <div class="formula">
                            <div class="formula-title">Расчет размера несжатого видео</div>
                            <div class="katex-formula" id="formula1"></div>
                            <div class="formula-explanation">
                                <p>где:</p>
                                <ul>
                                    <li><strong>Ширина</strong> - количество пикселей по горизонтали</li>
                                    <li><strong>Высота</strong> - количество пикселей по вертикали</li>
                                    <li><strong>Биты на пиксель</strong> - глубина цвета (обычно 24 бита для RGB)</li>
                                    <li><strong>Частота кадров</strong> - количество кадров в секунду</li>
                                    <li><strong>Время</strong> - длительность видео в секундах</li>
                                    <li><strong>Деление на 8</strong> - преобразование битов в байты</li>
                                </ul>
                            </div>
                        </div>

                        <div class="formula">
                            <div class="formula-title">Пример расчета для 4K видео</div>
                            <div class="katex-formula" id="formula2"></div>
                            <div class="formula-explanation">
                                <p>Для 4K видео (3840×2160, 24 бита, 30 fps) одна минута видео занимает около 35 ГБ без сжатия. Это объясняет необходимость сжатия для эффективного хранения и передачи.</p>
                            </div>
                        </div>

                        <p><strong>Практические последствия:</strong></p>
                        <ul>
                            <li>Полнометражный фильм (2 часа): ~4 ТБ</li>
                            <li>Потоковое вещание 4K: требуется пропускная способность ~1.5 Гбит/с на одного зрителя</li>
                            <li>Видеонаблюдение: неделя записи 4K видео требует ~35 ТБ хранилища</li>
                        </ul>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Процесс оцифровки видео</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            flowchart TD
                                A[Аналоговый видеосигнал] --> B[Дискретизация<br>по пространству]
                                B --> C[Квантование<br>по яркости и цвету]
                                C --> D[Кодирование цвета<br>RGB → YCbCr]
                                D --> E["Цифровое видео<br>(последовательность кадров)"]

                                F["Телевизионные стандарты<br>(NTSC, PAL, SECAM)"] --> A
                                G["Цветовые модели<br>(RGB, YUV, YCbCr)"] --> C
                                H["Субдискретизация<br>цветности (4:2:0, 4:2:2)"] --> D
                        </div>
                    </div>

                    <div class="text-content">
                        <p><strong>Математические основы:</strong></p>

                        <div class="formula">
                            <div class="formula-title">Преобразование RGB в YCbCr</div>
                            <div class="katex-formula" id="formula3"></div>
                            <div class="formula-explanation">
                                <p>где Y - яркостная компонента, Cb и Cr - цветоразностные компоненты. Это преобразование позволяет эффективно отделить информацию о яркости (важную для восприятия) от информации о цвете.</p>
                            </div>
                        </div>

                        <div class="formula">
                            <div class="formula-title">Субдискретизация цветности</div>
                            <div class="katex-formula" id="formula4"></div>
                            <div class="formula-explanation">
                                <p>Человеческое зрение более чувствительно к изменениям яркости, чем цвета. Субдискретизация цветности позволяет уменьшить объем цветовой информации без заметной потери качества.</p>
                            </div>
                        </div>

                        <p><strong>Этапы преобразования:</strong></p>
                        <ol>
                            <li><span class="highlight">Пространственная дискретизация</span>: преобразование непрерывного изображения в дискретную сетку пикселей</li>
                            <li><span class="highlight">Квантование</span>: преобразование непрерывных значений яркости и цвета в дискретные уровни</li>
                            <li><span class="highlight">Цветовое преобразование</span>: преобразование RGB в YCbCr для эффективного сжатия</li>
                            <li><span class="highlight">Субдискретизация</span>: уменьшение разрешения цветовых компонент</li>
                        </ol>
                    </div>
                </div>

                <div class="key-points">
                    <div class="key-points-title">Ключевые моменты:</div>
                    <ul>
                        <li>Несжатое 4K видео занимает около 35 ГБ в минуту</li>
                        <li>Пространственная дискретизация преобразует непрерывное изображение в дискретную сетку пикселей</li>
                        <li>Квантование преобразует непрерывные значения яркости и цвета в дискретные уровни</li>
                        <li>Преобразование RGB в YCbCr позволяет эффективно отделить яркость от цвета</li>
                        <li>Субдискретизация цветности уменьшает объем данных без заметной потери качества</li>
                    </ul>
                </div>
            </div>

            <!-- Раздел 2: Классификация -->
            <div class="section" id="section2">
                <h2 class="section-title">2. Классификация методов сжатия видео</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Сравнение методов сжатия</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            graph TD
                                A[Методы сжатия видео] --> B[Без потерь<br>Lossless]
                                A --> C[С потерями<br>Lossy]

                                B --> D[Принцип:<br>удаление избыточности<br>энтропийное кодирование]
                                C --> E[Принцип:<br>психовизуальное<br>моделирование]

                                D --> F[Сжатие 2:1 - 3:1<br>Качество: идентично оригиналу]
                                E --> G[Сжатие 10:1 - 1000:1<br>Качество: контролируемые потери]

                                F --> H[Применение:<br>архивы, монтаж,<br>медицинская визуализация]
                                G --> I[Применение:<br>стриминг, ТВ,<br>массовое распространение]
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Математические основы сжатия</h3>

                    <div class="formula">
                        <div class="formula-title">Энтропия Шеннона для видео</div>
                        <div class="katex-formula" id="formula5"></div>
                        <div class="formula-explanation">
                            <p>где:</p>
                            <ul>
                                <li>\( H(V) \) - энтропия видеопоследовательности</li>
                                <li>\( P(v_i) \) - вероятность появления символа \( v_i \)</li>
                                <li>\( n \) - количество различных символов в алфавите</li>
                            </ul>
                            <p>Энтропия Шеннона определяет теоретический предел сжатия данных без потерь. Для видео учитывается как пространственная, так и временная избыточность.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Энтропия источника данных определяет теоретический предел, до которого можно сжать данные без потерь. Для сжатия с потерями применяются психовизуальные модели, которые учитывают особенности человеческого зрения.</p>
                    </div>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Параметр</th>
                                <th>Lossless</th>
                                <th>Lossy</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Принцип работы</td>
                                <td>Удаление избыточности</td>
                                <td>Психовизуальное моделирование</td>
                            </tr>
                            <tr>
                                <td>Степень сжатия</td>
                                <td>2:1 - 3:1</td>
                                <td>10:1 - 1000:1</td>
                            </tr>
                            <tr>
                                <td>Качество</td>
                                <td>Идентично оригиналу</td>
                                <td>Контролируемые потери</td>
                            </tr>
                            <tr>
                                <td>Вычислительная сложность</td>
                                <td>Низкая-средняя</td>
                                <td>Очень высокая</td>
                            </tr>
                            <tr>
                                <td>Основные методы</td>
                                <td>RLE, LZW, Huffman</td>
                                <td>DCT, квантование, Motion Compensation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Раздел 3: Внутрикадровое сжатие -->
            <div class="section" id="section3">
                <h2 class="section-title">3. Внутрикадровое сжатие (Intraframe)</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Архитектура JPEG-подобного кодек</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            flowchart TD
                                A["Входное изображение<br>YCbCr"] --> B["Разбиение на блоки 8×8"]
                                B --> C["Дискретное косинусное<br>преобразование (DCT)"]
                                C --> D["Квантование<br>с использованием таблицы"]
                                D --> E["Зигзаг-сканирование<br>и RLE кодирование"]
                                E --> F["Энтропийное кодирование<br>Хаффмана"]
                                F --> G["Сжатые данные"]

                                H["Психовизуальная модель<br>определяет квантование"] --> D
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Дискретное косинусное преобразование (DCT)</h3>

                    <div class="formula">
                        <div class="formula-title">Двумерное DCT</div>
                        <div class="katex-formula" id="formula6"></div>
                        <div class="formula-explanation">
                            <p>где:</p>
                            <ul>
                                <li>\( F(u,v) \) - коэффициент DCT с частотными индексами u и v</li>
                                <li>\( f(x,y) \) - значение пикселя в позиции (x,y) блока 8×8</li>
                                <li>\( C(u), C(v) \) - нормировочные коэффициенты</li>
                                <li>\( N \) - размер блока (обычно 8)</li>
                            </ul>
                            <p>DCT преобразует блок пикселей из пространственной области в частотную, где энергия сигнала концентрируется в небольшом количестве низкочастотных коэффициентов.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">Обратное DCT (IDCT)</div>
                        <div class="katex-formula" id="formula7"></div>
                        <div class="formula-explanation">
                            <p>Обратное преобразование позволяет восстановить изображение из частотных коэффициентов. При сжатии с потерями некоторые высокочастотные коэффициенты обнуляются или квантуются грубо.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>DCT преобразует блок пикселей из пространственной области в частотную, где энергия сигнала концентрируется в небольшом количестве низкочастотных коэффициентов. Это позволяет эффективно сжимать изображение, отбрасывая малозначимые высокочастотные компоненты.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Квантование</h3>

                    <div class="formula">
                        <div class="formula-title">Квантование коэффициентов DCT</div>
                        <div class="katex-formula" id="formula8"></div>
                        <div class="formula-explanation">
                            <p>где:</p>
                            <ul>
                                <li>\( F_Q(u,v) \) - квантованный коэффициент DCT</li>
                                <li>\( F(u,v) \) - исходный коэффициент DCT</li>
                                <li>\( Q(u,v) \) - значение из матрицы квантования</li>
                                <li>\( round() \) - функция округления до ближайшего целого</li>
                            </ul>
                            <p>Квантование - это процесс уменьшения точности коэффициентов DCT. Высокочастотные коэффициенты квантуются грубее, так как они менее важны для визуального восприятия.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">Обратное квантование</div>
                        <div class="katex-formula" id="formula9"></div>
                        <div class="formula-explanation">
                            <p>Обратное квантование восстанавливает коэффициенты DCT, но с потерей информации. Это основная причина потерь в JPEG-подобных алгоритмах сжатия.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Квантование - основной источник потерь в JPEG-подобных алгоритмах. Матрица квантования определяет, насколько грубо квантуется каждый коэффициент DCT. Обычно высокочастотные коэффициенты квантуются грубее, так как они менее важны для визуального восприятия.</p>
                    </div>
                </div>
            </div>

            <!-- Раздел 4: Межкадровое сжатие -->
            <div class="section" id="section4">
                <h2 class="section-title">4. Межкадровое сжатие (Interframe)</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Архитектура MPEG-подобного кодек</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            flowchart TD
                                A["Входная видеопоследовательность"] --> B{"Тип кадра"}
                                B --> C[I-кадр]
                                B --> D[P-кадр]
                                B --> E[B-кадр]

                                C --> F["Внутрикадровое<br>сжатие (DCT)"]
                                D --> G["Предсказание<br>от предыдущих кадров"]
                                E --> H["Двунаправленное<br>предсказание"]

                                F --> I["Энтропийное<br>кодирование"]
                                G --> I
                                H --> I

                                I --> J["Сжатый<br>битстрим"]
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Ключевым отличием межкадрового сжатия является использование временной избыточности между соседними кадрами видео.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Типы кадров в MPEG</h3>

                    <div class="techniques-grid">
                        <div class="technique-card">
                            <div class="technique-title">I-кадры (Intra-coded)</div>
                            <div class="text-content">
                                <p>Сжимаются независимо, без ссылок на другие кадры. Служат точками доступа в потоке и точками восстановления при ошибках.</p>
                                <ul>
                                    <li>Сжатие: только внутрикадровое</li>
                                    <li>Размер: наибольший</li>
                                    <li>Частота: обычно каждые 0.5-2 секунды</li>
                                </ul>
                            </div>
                        </div>

                        <div class="technique-card">
                            <div class="technique-title">P-кадры (Predicted)</div>
                            <div class="text-content">
                                <p>Сжимаются с использованием предсказания от предыдущих I- или P-кадров. Содержат только разницу (ошибку предсказания).</p>
                                <ul>
                                    <li>Сжатие: межкадровое + внутрикадровое</li>
                                    <li>Размер: средний</li>
                                    <li>Зависимость: от предыдущих кадров</li>
                                </ul>
                            </div>
                        </div>

                        <div class="technique-card">
                            <div class="technique-title">B-кадры (Bidirectional)</div>
                            <div class="text-content">
                                <p>Сжимаются с использованием предсказания от предыдущих и последующих кадров. Наиболее эффективны по сжатию.</p>
                                <ul>
                                    <li>Сжатие: двунаправленное межкадровое</li>
                                    <li>Размер: наименьший</li>
                                    <li>Зависимость: от прошлых и будущих кадров</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Компенсация движения (Motion Compensation)</h3>

                    <div class="formula">
                        <div class="formula-title">Вектор движения</div>
                        <div class="katex-formula" id="formula10"></div>
                        <div class="formula-explanation">
                            <p>где \( (dx, dy) \) - смещение макроблока между текущим и опорным кадром. Вектор движения описывает, как сместился блок пикселей между кадрами.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">Ошибка предсказания</div>
                        <div class="katex-formula" id="formula11"></div>
                        <div class="formula-explanation">
                            <p>где \( C(x,y) \) - текущий блок, \( R(x+dx, y+dy) \) - предсказанный блок из опорного кадра. Ошибка предсказания кодируется с помощью DCT и квантования.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">Поиск движения</div>
                        <div class="katex-formula" id="formula12"></div>
                        <div class="formula-explanation">
                            <p>Алгоритм поиска движения минимизирует разницу между текущим блоком и блоками в области поиска опорного кадра. Полный перебор дает наилучший результат, но требует больших вычислений.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Компенсация движения - это процесс определения и кодирования движения объектов между кадрами. Векторы движения описывают, как сместились блоки пикселей, а ошибка предсказания кодирует остаточную разницу.</p>
                    </div>
                </div>
            </div>

            <!-- Раздел 5: Психовизуальные модели -->
            <div class="section" id="section5">
                <h2 class="section-title">5. Психовизуальные модели</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Основные эффекты</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            graph TD
                                A[Психовизуальные эффекты] --> B[Контрастная чувствительность]
                                A --> C[Пространственное маскирование]
                                A --> D[Временное маскирование]
                                A --> E[Цветовая чувствительность]

                                B --> F["Человеческий глаз<br>более чувствителен<br>к средним частотам"]
                                C --> G["Яркие области<br>маскируют детали<br>в соседних областях"]
                                D --> H["Быстрые движения<br>маскируют детали"]
                                E --> I["Более чувствителен<br>к яркости, чем к цвету"]
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Контрастная чувствительность</h3>

                    <div class="formula">
                        <div class="formula-title">Функция контрастной чувствительности (CSF)</div>
                        <div class="katex-formula" id="formula13"></div>
                        <div class="formula-explanation">
                            <p>где:</p>
                            <ul>
                                <li>\( CSF(f) \) - контрастная чувствительность на пространственной частоте f</li>
                                <li>\( f \) - пространственная частота в циклах на градус</li>
                            </ul>
                            <p>Человеческий глаз наиболее чувствителен к пространственным частотам около 2-8 циклов на градус. На высоких и низких частотах чувствительность снижается.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Контрастная чувствительность описывает способность человеческого глаза различать изменения яркости в зависимости от пространственной частоты. Это позволяет определить, какие частотные компоненты изображения наиболее важны для восприятия.</p>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Пространственное маскирование</h3>

                    <div class="formula">
                        <div class="formula-title">Порог видимости искажений</div>
                        <div class="katex-formula" id="formula14"></div>
                        <div class="formula-explanation">
                            <p>где:</p>
                            <ul>
                                <li>\( JND(x,y) \) - порог заметности искажений в позиции (x,y)</li>
                                <li>\( L(x,y) \) - локальная яркость</li>
                                <li>\( C(x,y) \) - локальная контрастность</li>
                                <li>\( f() \) - функция, определяемая экспериментально</li>
                            </ul>
                            <p>В областях с высокой яркостью и контрастностью искажения менее заметны. Это позволяет увеличить квантование в таких областях без ухудшения воспринимаемого качества.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Пространственное маскирование возникает, когда наличие одних визуальных стимулов делает другие менее заметными. Например, текстурированные области маскируют шум квантования лучше, чем гладкие области.</p>
                    </div>
                </div>
            </div>

            <!-- Раздел 6: Стандарты сжатия -->
            <div class="section" id="section6">
                <h2 class="section-title">6. Основные стандарты сжатия видео</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Эволюция стандартов</h3>
                    <div class="diagram">
                        <div class="mermaid">
                            timeline
                                title Эволюция стандартов сжатия видео
                                section 1990-е
                                    MPEG-1 : CD-видео (VCD)
                                    MPEG-2 : DVD, цифровое ТВ
                                section 2000-е
                                    MPEG-4 : Интернет, мобильные
                                    H.264/AVC : HD-видео, стриминг
                                section 2010-е
                                    H.265/HEVC : 4K, HDR
                                    VP9 : Веб-видео (YouTube)
                                section 2020-е
                                    AV1 : Открытый стандарт
                                    H.266/VVC : 8K и выше
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Сравнение стандартов</h3>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Стандарт</th>
                                <th>Год</th>
                                <th>Эффективность</th>
                                <th>Основное применение</th>
                                <th>Особенности</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>MPEG-2</td>
                                <td>1995</td>
                                <td>1x</td>
                                <td>DVD, цифровое ТВ</td>
                                <td>Первый массовый стандарт</td>
                            </tr>
                            <tr>
                                <td>H.264/AVC</td>
                                <td>2003</td>
                                <td>2x</td>
                                <td>Blu-ray, стриминг, видеоконференции</td>
                                <td>Баланс качества и сложности</td>
                            </tr>
                            <tr>
                                <td>H.265/HEVC</td>
                                <td>2013</td>
                                <td>2x</td>
                                <td>4K, HDR, мобильное видео</td>
                                <td>Высокая эффективность, сложность</td>
                            </tr>
                            <tr>
                                <td>VP9</td>
                                <td>2013</td>
                                <td>сопоставимо с H.265</td>
                                <td>YouTube, веб-видео</td>
                                <td>Открытый, бесплатный</td>
                            </tr>
                            <tr>
                                <td>AV1</td>
                                <td>2018</td>
                                <td>30% лучше H.265</td>
                                <td>Стриминг, реальное время</td>
                                <td>Открытый, перспективный</td>
                            </tr>
                            <tr>
                                <td>H.266/VVC</td>
                                <td>2020</td>
                                <td>50% лучше H.265</td>
                                <td>8K, 360°, AR/VR</td>
                                <td>Сверхвысокая эффективность</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Ключевые улучшения в современных стандартах</h3>

                    <div class="complexity-chart">
                        <div class="complexity-item">
                            <div class="complexity-title">Адаптивное разбиение</div>
                            <div class="text-content">От фиксированных макроблоков 16×16 к рекурсивному разбиению (CTU) до 128×128 с гибкой структурой.</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-title">Улучшенное предсказание</div>
                            <div class="text-content">От простого Motion Compensation к сложным методам с субпиксельной точностью и множественными reference кадрами.</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-title">Продвинутые преобразования</div>
                            <div class="text-content">От DCT к адаптивным преобразованиям (DCT/DST) и вейвлет-преобразованиям.</div>
                        </div>
                        <div class="complexity-item">
                            <div class="complexity-title">Энтропийное кодирование</div>
                            <div class="text-content">От Хаффмана к арифметическому и контекстно-адаптивному бинарному арифметическому кодированию (CABAC).</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Раздел 7: Современные кодеки -->
            <div class="section" id="section7">
                <h2 class="section-title">7. Современные видеокодеки</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Популярные видеокодеки</h3>

                    <div class="codec-grid">
                        <div class="codec-card">
                            <div class="codec-name">H.264 (AVC)</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Битрейт:</strong> 1-10 Мбит/с (HD)</p>
                                <p><strong>Применение:</strong> Blu-ray, стриминг (YouTube, Netflix), видеоконференции, мобильное видео</p>
                                <p><strong>Особенности:</strong> Баланс между качеством, сложностью и совместимостью</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">H.265 (HEVC)</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Битрейт:</strong> 0.5-5 Мбит/с (HD)</p>
                                <p><strong>Применение:</strong> 4K, HDR, мобильное видео, видеонаблюдение</p>
                                <p><strong>Особенности:</strong> В 2 раза эффективнее H.264, но сложнее вычислениями</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">VP9</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Битрейт:</strong> 0.5-5 Мбит/с (HD)</p>
                                <p><strong>Применение:</strong> YouTube, веб-видео, открытые платформы</p>
                                <p><strong>Особенности:</strong> Открытый и бесплатный, сопоставим с H.265</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">AV1</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Битрейт:</strong> 0.4-4 Мбит/с (HD)</p>
                                <p><strong>Применение:</strong> Стриминг (Netflix, YouTube), реальное время</p>
                                <p><strong>Особенности:</strong> Открытый, на 30% эффективнее H.265, но сложнее вычислениями</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">H.266 (VVC)</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Битрейт:</strong> 0.3-3 Мбит/с (HD)</p>
                                <p><strong>Применение:</strong> 8K, 360°, AR/VR, HDR</p>
                                <p><strong>Особенности:</strong> На 50% эффективнее H.265, очень высокая вычислительная сложность</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">Apple ProRes</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Сжатие:</strong> 2:1 - 8:1</p>
                                <p><strong>Применение:</strong> Профессиональный видеомонтаж, кинопроизводство</p>
                                <p><strong>Особенности:</strong> Высокое качество при редактировании, малая вычислительная нагрузка при декодировании</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">DNxHD</div>
                            <div class="codec-type lossy">Lossy</div>
                            <div class="text-content">
                                <p><strong>Сжатие:</strong> 4:1 - 8:1</p>
                                <p><strong>Применение:</strong> Профессиональный видеомонтаж</p>
                                <p><strong>Особенности:</strong> Аналог ProRes от Avid, популярен в профессиональных студиях</p>
                            </div>
                        </div>

                        <div class="codec-card">
                            <div class="codec-name">FFV1</div>
                            <div class="codec-type lossless">Lossless</div>
                            <div class="text-content">
                                <p><strong>Сжатие:</strong> 2:1 - 3:1</p>
                                <p><strong>Применение:</strong> Архивация, цифровое сохранение</p>
                                <p><strong>Особенности:</strong> Открытый lossless-кодек, поддерживается FFmpeg</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Сравнение эффективности</h3>

                    <div class="formula">
                        <div class="formula-title">BD-rate метрика</div>
                        <div class="katex-formula" id="formula15"></div>
                        <div class="formula-explanation">
                            <p>где \( R_1 \) и \( R_2 \) - битрейты двух кодеков при одинаковом качестве. Отрицательное значение BD-rate означает, что кодек 2 эффективнее кодека 1.</p>
                        </div>
                    </div>

                    <div class="text-content">
                        <p><strong>Сравнительная эффективность (при одинаковом качестве):</strong></p>
                        <ul>
                            <li>H.265 vs H.264: ~50% экономии битрейта</li>
                            <li>AV1 vs H.265: ~30% экономии битрейта</li>
                            <li>H.266 vs H.265: ~50% экономии битрейта</li>
                            <li>AV1 vs H.264: ~65% экономии битрейта</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Раздел 8: Форматы контейнеров -->
            <div class="section" id="section8">
                <h2 class="section-title">8. Форматы контейнеров</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Характеристики форматов</h3>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Формат</th>
                                <th>Разработчик</th>
                                <th>Поддержка кодеков</th>
                                <th>Особенности</th>
                                <th>Применение</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>MP4</td>
                                <td>MPEG</td>
                                <td>H.264, H.265, MPEG-4</td>
                                <td>Универсальный, хорошая совместимость</td>
                                <td>Стриминг, мобильные устройства</td>
                            </tr>
                            <tr>
                                <td>MKV</td>
                                <td>Open Source</td>
                                <td>Практически все</td>
                                <td>Гибкий, поддерживает множество дорожек и субтитров</td>
                                <td>Хранение, архивирование</td>
                            </tr>
                            <tr>
                                <td>AVI</td>
                                <td>Microsoft</td>
                                <td>Старые кодеки</td>
                                <td>Простой, ограниченные возможности</td>
                                <td>Устаревшие системы</td>
                            </tr>
                            <tr>
                                <td>WebM</td>
                                <td>Google</td>
                                <td>VP8, VP9, AV1</td>
                                <td>Оптимизирован для веба, открытый</td>
                                <td>Веб-видео, HTML5</td>
                            </tr>
                            <tr>
                                <td>MOV</td>
                                <td>Apple</td>
                                <td>ProRes, H.264, H.265</td>
                                <td>Высокое качество, хорош для монтажа</td>
                                <td>Профессиональное видео, экосистема Apple</td>
                            </tr>
                            <tr>
                                <td>TS</td>
                                <td>MPEG</td>
                                <td>MPEG-2, H.264</td>
                                <td>Устойчив к ошибкам, потоковая передача</td>
                                <td>Цифровое ТВ, IPTV</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Структура медиаконтейнера</h3>

                    <div class="diagram">
                        <div class="mermaid">
                            graph TD
                                A[Медиаконтейнер] --> B[Метаданные]
                                A --> C[Видеодорожка]
                                A --> D[Аудиодорожка]
                                A --> E[Дорожка субтитров]
                                A --> F[Другие дорожки]

                                B --> G["Информация о файле,<br>длительность,<br>разрешение"]
                                C --> H["Сжатые видеоданные<br>(кодек, битрейт)"]
                                D --> I["Сжатые аудиоданные<br>(кодек, битрейт)"]
                                E --> J["Текстовые данные<br>или изображения"]
                                F --> K["Главы, меню,<br>метаданные"]
                        </div>
                    </div>

                    <div class="text-content">
                        <p>Медиаконтейнер - это формат файла, который содержит сжатые видеоданные, аудиоданные и метаданные в единой структуре. Контейнер определяет, как эти данные организованы и синхронизированы, но не определяет методы сжатия.</p>
                    </div>
                </div>
            </div>

            <!-- Раздел 9: Практика -->
            <div class="section" id="section9">
                <h2 class="section-title">9. Практические аспекты</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Рекомендации по применению</h3>

                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Применение</th>
                                <th>Рекомендуемый кодек</th>
                                <th>Битрейт</th>
                                <th>Контейнер</th>
                                <th>Библиотеки</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Веб-стриминг</td>
                                <td>H.264, VP9, AV1</td>
                                <td>1-8 Мбит/с (HD)</td>
                                <td>MP4, WebM</td>
                                <td>FFmpeg, libavcodec</td>
                            </tr>
                            <tr>
                                <td>Видеоконференции</td>
                                <td>H.264, VP8</td>
                                <td>0.5-2 Мбит/с</td>
                                <td>RTP, WebRTC</td>
                                <td>WebRTC, GStreamer</td>
                            </tr>
                            <tr>
                                <td>Монтаж</td>
                                <td>ProRes, DNxHD</td>
                                <td>50-200 Мбит/с</td>
                                <td>MOV, MXF</td>
                                <td>FFmpeg, SDK производителей</td>
                            </tr>
                            <tr>
                                <td>Архивация</td>
                                <td>H.265, AV1</td>
                                <td>2-10 Мбит/с (HD)</td>
                                <td>MKV, MP4</td>
                                <td>FFmpeg, x265, libaom</td>
                            </tr>
                            <tr>
                                <td>Мобильные приложения</td>
                                <td>H.264, H.265</td>
                                <td>0.5-5 Мбит/с</td>
                                <td>MP4</td>
                                <td>MediaCodec (Android), VideoToolbox (iOS)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Пример реализации на Python</h3>

                    <div class="code-block"><pre>
import cv2
import numpy as np

def calculate_video_size(width, height, fps, duration, bpp=24):
    """Расчет размера несжатого видео"""
    pixels_per_frame = width * height
    bits_per_frame = pixels_per_frame * bpp
    total_bits = bits_per_frame * fps * duration
    total_bytes = total_bits / 8
    return total_bytes

def rgb_to_ycbcr(r, g, b):
    """Преобразование RGB в YCbCr"""
    y = 0.299 * r + 0.587 * g + 0.114 * b
    cb = 128 - 0.168736 * r - 0.331264 * g + 0.5 * b
    cr = 128 + 0.5 * r - 0.418688 * g - 0.081312 * b
    return y, cb, cr

def dct_2d(block):
    """2D DCT преобразование блока 8x8"""
    m, n = block.shape
    dct_result = np.zeros((m, n))

    for u in range(m):
        for v in range(n):
            sum_val = 0
            for x in range(m):
                for y in range(n):
                    cos1 = np.cos((2*x + 1) * u * np.pi / (2*m))
                    cos2 = np.cos((2*y + 1) * v * np.pi / (2*n))
                    sum_val += block[x, y] * cos1 * cos2

            cu = 1/np.sqrt(2) if u == 0 else 1
            cv = 1/np.sqrt(2) if v == 0 else 1
            dct_result[u, v] = 2/np.sqrt(m*n) * cu * cv * sum_val

    return dct_result

def quantization(dct_block, quantization_table, quality=50):
    """Квантование DCT коэффициентов"""
    if quality <= 0:
        quality = 1
    if quality > 100:
        quality = 100

    # Масштабирование таблицы квантования в зависимости от качества
    scale_factor = 5000 / quality if quality < 50 else 200 - 2 * quality
    scaled_quant_table = quantization_table * scale_factor / 100

    # Квантование
    quantized = np.round(dct_block / scaled_quant_table)
    return quantized

# Пример использования
if __name__ == "__main__":
    # Расчет для 1080p видео
    size = calculate_video_size(1920, 1080, 30, 60)  # 60 секунд
    print(f"Размер несжатого 1080p видео (60 сек): {size / (1024**3):.2f} ГБ")

    # Пример преобразования цвета
    r, g, b = 255, 128, 64
    y, cb, cr = rgb_to_ycbcr(r, g, b)
    print(f"RGB({r},{g},{b}) -> YCbCr({y:.1f},{cb:.1f},{cr:.1f})")

    # Пример DCT
    test_block = np.random.randint(0, 256, (8, 8)) - 128  # Смещение для DCT
    dct_result = dct_2d(test_block)
    print("DCT преобразование выполнено")
    </pre>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Формулы для практических расчетов</h3>

                    <div class="formula">
                        <div class="formula-title">Коэффициент сжатия видео</div>
                        <div class="katex-formula" id="formula16"></div>
                        <div class="formula-explanation">
                            <p>Показывает, во сколько раз сжатые видеоданные меньше исходных. Для современных кодеков типичные значения от 10:1 до 1000:1.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">Эффективность кодирования</div>
                        <div class="katex-formula" id="formula17"></div>
                        <div class="formula-explanation">
                            <p>Показывает, насколько близко фактический битрейт приближается к теоретическому пределу сжатия. Значение больше 1 указывает на неэффективное кодирование.</p>
                        </div>
                    </div>

                    <div class="formula">
                        <div class="formula-title">PSNR (Peak Signal-to-Noise Ratio)</div>
                        <div class="katex-formula" id="formula18"></div>
                        <div class="formula-explanation">
                            <p>где \( MAX \) - максимально возможное значение пикселя, \( MSE \) - среднеквадратичная ошибка между исходным и сжатым изображением. PSNR широко используется для объективной оценки качества сжатия.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Раздел 10: Программные реализации -->
            <div class="section" id="section10">
                <h2 class="section-title">10. Программные реализации на Python</h2>

                <div class="subsection">
                    <h3 class="subsection-title">Библиотеки для работы с видео</h3>

                    <div class="library-grid">
                        <div class="library-card">
                            <div class="library-name">OpenCV</div>
                            <div class="text-content">
                                <p>Библиотека компьютерного зрения с поддержкой обработки видео. Позволяет захватывать, обрабатывать и сохранять видео.</p>
                                <p><strong>Установка:</strong> <code>pip install opencv-python</code></p>
                            </div>
                        </div>

                        <div class="library-card">
                            <div class="library-name">FFmpeg (via ffmpeg-python)</div>
                            <div class="text-content">
                                <p>Мощная библиотека для обработки мультимедиа. Поддерживает практически все кодеки и форматы.</p>
                                <p><strong>Установка:</strong> <code>pip install ffmpeg-python</code></p>
                            </div>
                        </div>

                        <div class="library-card">
                            <div class="library-name">MoviePy</div>
                            <div class="text-content">
                                <p>Библиотека для редактирования видео. Позволяет легко обрезать, склеивать и обрабатывать видео.</p>
                                <p><strong>Установка:</strong> <code>pip install moviepy</code></p>
                            </div>
                        </div>

                        <div class="library-card">
                            <div class="library-name">PyAV</div>
                            <div class="text-content">
                                <p>Python-биндинги для FFmpeg. Предоставляет низкоуровневый доступ к функциям FFmpeg.</p>
                                <p><strong>Установка:</strong> <code>pip install av</code></p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="subsection">
                    <h3 class="subsection-title">Пример работы с видео в OpenCV</h3>

                    <div class="code-block"><pre>
import cv2
import numpy as np

def extract_frames(video_path, output_dir, max_frames=100):
    """Извлечение кадров из видео"""
    cap = cv2.VideoCapture(video_path)
    frame_count = 0

    while cap.isOpened() and frame_count < max_frames:
        ret, frame = cap.read()
        if not ret:
            break

        # Сохранение кадра
        cv2.imwrite(f"{output_dir}/frame_{frame_count:04d}.jpg", frame)
        frame_count += 1

    cap.release()
    print(f"Извлечено {frame_count} кадров")

def compress_frame(frame, quality=50):
    """Сжатие кадра с помощью JPEG"""
    encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
    result, encimg = cv2.imencode('.jpg', frame, encode_param)
    return encimg

def motion_estimation(prev_frame, curr_frame, block_size=16):
    """Оценка движения между кадрами"""
    height, width = prev_frame.shape
    motion_vectors = []

    for y in range(0, height, block_size):
        for x in range(0, width, block_size):
            # Поиск наилучшего совпадения в области поиска
            best_match = (0, 0)
            min_error = float('inf')

            search_range = 16  # Область поиска

            for dy in range(-search_range, search_range + 1):
                for dx in range(-search_range, search_range + 1):
                    # Проверка границ
                    if (y + dy < 0 or y + dy + block_size > height or
                        x + dx < 0 or x + dx + block_size > width):
                        continue

                    # Вычисление ошибки
                    error = np.sum(np.abs(
                        curr_frame[y:y+block_size, x:x+block_size] -
                        prev_frame[y+dy:y+dy+block_size, x+dx:x+dx+block_size]
                    ))

                    if error < min_error:
                        min_error = error
                        best_match = (dx, dy)

            motion_vectors.append(((x, y), best_match))

    return motion_vectors

# Пример использования
if __name__ == "__main__":
    # Создание тестового видео (синусоидальная волна)
    width, height = 640, 480
    fps = 30
    duration = 5  # секунд

    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    out = cv2.VideoWriter('test_video.avi', fourcc, fps, (width, height))

    for i in range(fps * duration):
        # Создание кадра с движущейся синусоидальной волной
        frame = np.zeros((height, width, 3), dtype=np.uint8)
        for y in range(height):
            for x in range(width):
                intensity = 128 + 127 * np.sin(2 * np.pi * (x + i * 2) / 100)
                frame[y, x] = [intensity, intensity, intensity]

        out.write(frame)

    out.release()
    print("Тестовое видео создано")
    </pre>
                    </div>
                </div>
            </div>

            <!-- Раздел: Тест -->
            <div class="section" id="quiz">
                <h2 class="section-title">Тест: Проверка знаний</h2>

                <div class="quiz-section">
                    <div class="quiz-question">1. Какой тип кадра в MPEG сжимается независимо от других кадров?</div>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="true">I-кадр</div>
                        <div class="quiz-option" data-correct="false">P-кадр</div>
                        <div class="quiz-option" data-correct="false">B-кадр</div>
                        <div class="quiz-option" data-correct="false">D-кадр</div>
                    </div>
                    <div class="quiz-feedback">Правильно! I-кадры (Intra-coded) сжимаются независимо и служат точками доступа в видеопотоке.</div>
                </div>

                <div class="quiz-section">
                    <div class="quiz-question">2. Какой кодек обеспечивает наибольшую эффективность сжатия на сегодняшний день?</div>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">H.264</div>
                        <div class="quiz-option" data-correct="false">H.265</div>
                        <div class="quiz-option" data-correct="true">H.266 (VVC)</div>
                        <div class="quiz-option" data-correct="false">MPEG-2</div>
                    </div>
                    <div class="quiz-feedback">Верно! H.266 (VVC) обеспечивает примерно на 50% лучшее сжатие по сравнению с H.265, но требует значительно больше вычислительных ресурсов.</div>
                </div>

                <div class="quiz-section">
                    <div class="quiz-question">3. Какой эффект психовизуального восприятия позволяет уменьшить разрешение цветовых компонент без заметной потери качества?</div>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">Контрастная чувствительность</div>
                        <div class="quiz-option" data-correct="false">Пространственное маскирование</div>
                        <div class="quiz-option" data-correct="true">Пониженная чувствительность к цвету</div>
                        <div class="quiz-option" data-correct="false">Временное маскирование</div>
                    </div>
                    <div class="quiz-feedback">Правильно! Человеческий глаз менее чувствителен к изменениям цвета, чем к изменениям яркости, что позволяет использовать субдискретизацию цветности.</div>
                </div>

                <div class="quiz-section">
                    <div class="quiz-question">4. Какой контейнер оптимален для веб-видео с открытыми кодеками?</div>
                    <div class="quiz-options">
                        <div class="quiz-option" data-correct="false">MP4</div>
                        <div class="quiz-option" data-correct="true">WebM</div>
                        <div class="quiz-option" data-correct="false">AVI</div>
                        <div class="quiz-option" data-correct="false">MOV</div>
                    </div>
                    <div class="quiz-feedback">Верно! WebM специально разработан для веб-видео и оптимизирован для работы с открытыми кодеками VP8, VP9 и AV1.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Инициализация Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            securityLevel: 'loose',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            }
        });

        // Прогресс бар
        window.addEventListener('scroll', function() {
            const winHeight = window.innerHeight;
            const docHeight = document.documentElement.scrollHeight;
            const scrollTop = window.pageYOffset;
            const scrollPercent = scrollTop / (docHeight - winHeight);
            const progressBar = document.getElementById('progressBar');
            progressBar.style.transform = `scaleX(${scrollPercent})`;
        });

        // Плавная прокрутка для навигации
        document.querySelectorAll('.nav-item').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetElement = document.querySelector(targetId);
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });

                // Закрытие мобильного меню после клика
                const navigation = document.getElementById('navigation');
                navigation.classList.remove('active');
            });
        });

        // Динамическое обновление Mermaid при изменении размера окна
        window.addEventListener('resize', function() {
            mermaid.contentLoaded();
        });

        // Мобильное меню
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const navigation = document.getElementById('navigation');

        mobileMenuToggle.addEventListener('click', function() {
            navigation.classList.toggle('active');
        });

        // Тестовая логика
        document.querySelectorAll('.quiz-option').forEach(option => {
            option.addEventListener('click', function() {
                const isCorrect = this.getAttribute('data-correct') === 'true';
                const feedback = this.parentElement.nextElementSibling;

                // Сброс всех вариантов в этом вопросе
                this.parentElement.querySelectorAll('.quiz-option').forEach(opt => {
                    opt.classList.remove('correct', 'incorrect');
                });

                // Показ правильного/неправильного ответа
                if (isCorrect) {
                    this.classList.add('correct');
                    feedback.classList.add('correct');
                    feedback.classList.remove('incorrect');
                } else {
                    this.classList.add('incorrect');
                    feedback.classList.add('incorrect');
                    feedback.classList.remove('correct');

                    // Показать правильный ответ
                    const correctOption = this.parentElement.querySelector('.quiz-option[data-correct="true"]');
                    correctOption.classList.add('correct');
                }
            });
        });

        // Рендеринг формул KaTeX после загрузки DOM
        document.addEventListener('DOMContentLoaded', function() {
            // Формула 1
            katex.render("\\text{Размер} = \\frac{\\text{Ширина} \\times \\text{Высота} \\times \\text{Биты на пиксель} \\times \\text{Частота кадров} \\times \\text{Время}}{8}", document.getElementById('formula1'), {
                throwOnError: false
            });

            // Формула 2
            katex.render("\\text{Размер} = \\frac{3840 \\times 2160 \\times 24 \\times 30 \\times 60}{8 \\times 1024^3} \\approx 35 \\text{ ГБ}", document.getElementById('formula2'), {
                throwOnError: false
            });

            // Формула 3
            katex.render("\\begin{cases} Y = 0.299R + 0.587G + 0.114B \\\\ Cb = 128 - 0.168736R - 0.331264G + 0.5B \\\\ Cr = 128 + 0.5R - 0.418688G - 0.081312B \\end{cases}", document.getElementById('formula3'), {
                throwOnError: false,
                displayMode: true
            });

            // Формула 4
            katex.render("4:2:0 \\Rightarrow \\text{Цветность: } \\frac{1}{4} \\text{ от яркости}", document.getElementById('formula4'), {
                throwOnError: false
            });

            // Формула 5
            katex.render("H(V) = -\\sum_{i=1}^{n} P(v_i) \\log_2 P(v_i)", document.getElementById('formula5'), {
                throwOnError: false
            });

            // Формула 6
            katex.render("F(u,v) = \\frac{2}{N} C(u)C(v) \\sum_{x=0}^{N-1} \\sum_{y=0}^{N-1} f(x,y) \\cos\\left[\\frac{(2x+1)u\\pi}{2N}\\right] \\cos\\left[\\frac{(2y+1)v\\pi}{2N}\\right]", document.getElementById('formula6'), {
                throwOnError: false
            });

            // Формула 7
            katex.render("f(x,y) = \\frac{2}{N} \\sum_{u=0}^{N-1} \\sum_{v=0}^{N-1} C(u)C(v) F(u,v) \\cos\\left[\\frac{(2x+1)u\\pi}{2N}\\right] \\cos\\left[\\frac{(2y+1)v\\pi}{2N}\\right]", document.getElementById('formula7'), {
                throwOnError: false
            });

            // Формула 8
            katex.render("F_Q(u,v) = round\\left(\\frac{F(u,v)}{Q(u,v)}\\right)", document.getElementById('formula8'), {
                throwOnError: false
            });

            // Формула 9
            katex.render("F_R(u,v) = F_Q(u,v) \\times Q(u,v)", document.getElementById('formula9'), {
                throwOnError: false
            });

            // Формула 10
            katex.render("\\vec{v} = (dx, dy)", document.getElementById('formula10'), {
                throwOnError: false
            });

            // Формула 11
            katex.render("E(x,y) = C(x,y) - R(x+dx, y+dy)", document.getElementById('formula11'), {
                throwOnError: false
            });

            // Формула 12
            katex.render("(dx, dy) = \\arg\\min_{(dx,dy) \\in S} \\sum |C(x,y) - R(x+dx, y+dy)|", document.getElementById('formula12'), {
                throwOnError: false
            });

            // Формула 13
            katex.render("CSF(f) = 2.6(0.0192+0.114f)e^{-(0.114f)^{1.1}}", document.getElementById('formula13'), {
                throwOnError: false
            });

            // Формула 14
            katex.render("JND(x,y) = f(L(x,y), C(x,y))", document.getElementById('formula14'), {
                throwOnError: false
            });

            // Формула 15
            katex.render("BD\\text{-}rate = \\frac{R_2 - R_1}{R_1} \\times 100\\%", document.getElementById('formula15'), {
                throwOnError: false
            });

            // Формула 16
            katex.render("\\text{Compression Ratio} = \\frac{\\text{Original Size}}{\\text{Compressed Size}}", document.getElementById('formula16'), {
                throwOnError: false
            });

            // Формула 17
            katex.render("\\text{Coding Efficiency} = \\frac{\\text{Theoretical Limit}}{\\text{Actual Bitrate}}", document.getElementById('formula17'), {
                throwOnError: false
            });

            // Формула 18
            katex.render("PSNR = 10 \\log_{10}\\left(\\frac{MAX^2}{MSE}\\right)", document.getElementById('formula18'), {
                throwOnError: false
            });

            // Исправление отображения строчных формул
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false
            });
        });
    </script>
</body>
</html>